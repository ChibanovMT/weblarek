# Проектная работа "Веб-ларек"

Стек: HTML, SCSS, TS, Vite

Структура проекта:
- src/ — исходные файлы проекта
- src/components/ — папка с JS компонентами
- src/components/base/ — папка с базовым кодом

Важные файлы:
- index.html — HTML-файл главной страницы
- src/types/index.ts — файл с типами
- src/main.ts — точка входа приложения
- src/scss/styles.scss — корневой файл стилей
- src/utils/constants.ts — файл с константами
- src/utils/utils.ts — файл с утилитами

## Установка и запуск
Для установки и запуска проекта необходимо выполнить команды

```
npm install
npm run start
```

или

```
yarn
yarn start
```
## Сборка

```
npm run build
```

или

```
yarn build
```
# Интернет-магазин «Web-Larёk»
«Web-Larёk» — это интернет-магазин с товарами для веб-разработчиков, где пользователи могут просматривать товары, добавлять их в корзину и оформлять заказы. Сайт предоставляет удобный интерфейс с модальными окнами для просмотра деталей товаров, управления корзиной и выбора способа оплаты, обеспечивая полный цикл покупки с отправкой заказов на сервер.

## Архитектура приложения

Код приложения разделен на слои согласно парадигме MVP (Model-View-Presenter), которая обеспечивает четкое разделение ответственности между классами слоев Model и View. Каждый слой несет свой смысл и ответственность:

Model - слой данных, отвечает за хранение и изменение данных.  
View - слой представления, отвечает за отображение данных на странице.  
Presenter - презентер содержит основную логику приложения и  отвечает за связь представления и данных.

Взаимодействие между классами обеспечивается использованием событийно-ориентированного подхода. Модели и Представления генерируют события при изменении данных или взаимодействии пользователя с приложением, а Презентер обрабатывает эти события используя методы как Моделей, так и Представлений.

### Базовый код

#### Класс Component
Является базовым классом для всех компонентов интерфейса.
Класс является дженериком и принимает в переменной `T` тип данных, которые могут быть переданы в метод `render` для отображения.

Конструктор:  
`constructor(container: HTMLElement)` - принимает ссылку на DOM элемент за отображение, которого он отвечает.

Поля класса:  
`container: HTMLElement` - поле для хранения корневого DOM элемента компонента.

Методы класса:  
`render(data?: Partial<T>): HTMLElement` - Главный метод класса. Он принимает данные, которые необходимо отобразить в интерфейсе, записывает эти данные в поля класса и возвращает ссылку на DOM-элемент. Предполагается, что в классах, которые будут наследоваться от `Component` будут реализованы сеттеры для полей с данными, которые будут вызываться в момент вызова `render` и записывать данные в необходимые DOM элементы.  
`setImage(element: HTMLImageElement, src: string, alt?: string): void` - утилитарный метод для модификации DOM-элементов `<img>`


#### Класс Api
Содержит в себе базовую логику отправки запросов.

Конструктор:  
`constructor(baseUrl: string, options: RequestInit = {})` - В конструктор передается базовый адрес сервера и опциональный объект с заголовками запросов.

Поля класса:  
`baseUrl: string` - базовый адрес сервера  
`options: RequestInit` - объект с заголовками, которые будут использованы для запросов.

Методы:  
`get(uri: string): Promise<object>` - выполняет GET запрос на переданный в параметрах ендпоинт и возвращает промис с объектом, которым ответил сервер  
`post(uri: string, data: object, method: ApiPostMethods = 'POST'): Promise<object>` - принимает объект с данными, которые будут переданы в JSON в теле запроса, и отправляет эти данные на ендпоинт переданный как параметр при вызове метода. По умолчанию выполняется `POST` запрос, но метод запроса может быть переопределен заданием третьего параметра при вызове.  
`handleResponse(response: Response): Promise<object>` - защищенный метод проверяющий ответ сервера на корректность и возвращающий объект с данными полученный от сервера или отклоненный промис, в случае некорректных данных.

#### Класс EventEmitter
Брокер событий реализует паттерн "Наблюдатель", позволяющий отправлять события и подписываться на события, происходящие в системе. Класс используется для связи слоя данных и представления.

Конструктор класса не принимает параметров.

Поля класса:  
`_events: Map<string | RegExp, Set<Function>>)` -  хранит коллекцию подписок на события. Ключи коллекции - названия событий или регулярное выражение, значения - коллекция функций обработчиков, которые будут вызваны при срабатывании события.

Методы класса:  
`on<T extends object>(event: EventName, callback: (data: T) => void): void` - подписка на событие, принимает название события и функцию обработчик.  
`emit<T extends object>(event: string, data?: T): void` - инициализация события. При вызове события в метод передается название события и объект с данными, который будет использован как аргумент для вызова обработчика.  
`trigger<T extends object>(event: string, context?: Partial<T>): (data: T) => void` - возвращает функцию, при вызове которой инициализируется требуемое в параметрах событие с передачей в него данных из второго параметра.

## Данные

В приложении используются два основных интерфейса данных: товар и покупатель. Также используется базовый интерфейс клиента API. Ниже приведены интерфейсы и их назначение.

Назначение интерфейсов:
- `IApi`: контракт для клиентов API, обеспечивающий единообразные методы `get` и `post`.
- `IProduct`: структура данных товара каталога.
- `IBuyer`: структура данных покупателя, используемая при оформлении заказа.

Интерфейсы:

```ts
export type ApiPostMethods = 'POST' | 'PUT' | 'DELETE';

export interface IApi {
    get<T extends object>(uri: string): Promise<T>;
    post<T extends object>(uri: string, data: object, method?: ApiPostMethods): Promise<T>;
}

export type TPayment = 'online' | 'upon-receipt'; // пример вариантов оплаты

export interface IProduct {
    id: string;
    description: string;
    image: string;
    title: string;
    category: string;
    price: number | null;
}

export interface IBuyer {
    payment: TPayment;
    email: string;
    phone: string;
    address: string;
}
```

Кратко о полях:
- `IProduct.id`: идентификатор товара; `title`, `image`, `category`: атрибуты карточки товара.
- `IProduct.price`: цена или `null`, если товар недоступен к покупке.
- `IProduct.description`: текстовое описание товара.
- `IBuyer.payment`: способ оплаты (одно из значений `TPayment`).
- `IBuyer.address`: адрес доставки; `email`, `phone`: контакты покупателя.

## Модели данных

Модели данных инкапсулируют хранение и работу с данными домена. Они не занимаются отрисовкой и не знают о DOM; их задача — валидировать, хранить и предоставлять данные презентеру/представлению.

### Класс User

- Назначение и зона ответственности: хранит и предоставляет данные покупателя в процессе оформления заказа. Может использоваться для валидации и последующей передачи данных в модель заказа.
- Конструктор:
  - `constructor(data: IUser)` — принимает объект, соответствующий интерфейсу `IUser`.
- Поля:
  - `payment: string` — выбранный покупателем способ оплаты.
  - `address: string` — адрес доставки заказа.
  - `email: string` — электронная почта для связи и уведомлений.
  - `phone: string` — контактный номер телефона покупателя.
- Методы: на текущем этапе отдельные методы не требуются. При необходимости могут быть добавлены методы валидации: например, `isValidEmail(): boolean`.

Планируемые модели (для последующих шагов):

- `Product` (на уровне интерфейса `IProduct`): модель отдельного товара каталога; может дополнительно предоставлять вычисляемые свойства (например, форматированная цена) и инварианты (товар доступен к покупке только при ненулевой цене).
- `Cart` (корзина): хранение списка выбранных товаров, подсчёт суммарной стоимости, добавление/удаление позиций, очистка.
- `Order` (заказ): агрегация данных модели покупателя (`User`, реализующей `IBuyer`) и содержимого `Cart` для отправки на сервер, проверка полноты данных.

Таким образом, интерфейсы в `src/types/index.ts` определяют «форму» данных, а модели данных обеспечивают рабочую логику вокруг этих структур и используются презентером для управления состоянием приложения.


### Класс Catalog (каталог товаров)

- Назначение и зона ответственности: хранит полный список товаров каталога и выбранный товар для подробного просмотра. Не отвечает за представление и сетевые запросы.
- Конструктор:
  - `constructor(products?: IProduct[])` — опционально принимает начальный массив товаров.
- Поля:
  - `products: IProduct[]` — массив всех товаров каталога.
  - `selectedProduct: IProduct | null` — товар, выбранный для подробного отображения.
- Методы:
  - `setProducts(products: IProduct[]): void` — сохраняет массив товаров, полученный параметром.
  - `getProducts(): ReadonlyArray<IProduct>` — возвращает текущий массив товаров (без возможности мутации извне).
  - `getProductById(id: string): IProduct | undefined` — возвращает товар по идентификатору или `undefined`, если не найден.
  - `setSelectedProduct(product: IProduct | null): void` — сохраняет товар для подробного отображения (или сбрасывает выбор при `null`).
  - `getSelectedProduct(): IProduct | null` — возвращает товар для подробного отображения.

### Класс Cart (корзина)

- Назначение и зона ответственности: хранит товары, выбранные пользователем для покупки, и предоставляет операции над этим набором.
- Конструктор:
  - `constructor(items?: IProduct[])` — опционально принимает начальный массив выбранных товаров.
- Поля:
  - `items: IProduct[]` — товары, находящиеся в корзине.
- Методы:
  - `getItems(): ReadonlyArray<IProduct>` — возвращает содержимое корзины.
  - `add(product: IProduct): void` — добавляет товар в корзину.
  - `remove(productId: string): void` — удаляет товар из корзины по идентификатору.
  - `clear(): void` — очищает корзину.
  - `getTotal(): number` — возвращает суммарную стоимость всех товаров с заданной ценой (`price !== null`).
  - `getCount(): number` — возвращает количество товаров в корзине.
  - `has(productId: string): boolean` — проверяет наличие товара в корзине по его `id`.

### Класс User (покупатель)

- Назначение и зона ответственности: хранит и обновляет данные покупателя, обеспечивает их получение, очистку и валидацию. Соответствует интерфейсу `IBuyer`.
- Конструктор:
  - `constructor(data?: Partial<IBuyer>)` — опционально принимает частичные данные покупателя для инициализации.
- Поля:
  - `payment: TPayment | null` — выбранный вид оплаты.
  - `address: string` — адрес доставки.
  - `phone: string` — телефон покупателя.
  - `email: string` — электронная почта покупателя.
- Методы:
  - `set(data: Partial<IBuyer>): void` — сохраняет/обновляет данные покупателя; поддерживает частичное обновление (например, только адрес или только телефон) без затирания прочих полей.
  - `setPayment(payment: TPayment): void` — установить способ оплаты.
  - `setAddress(address: string): void` — установить адрес доставки.
  - `setPhone(phone: string): void` — установить телефон.
  - `setEmail(email: string): void` — установить e-mail.
  - `get(): IBuyer` — возвращает все данные покупателя единым объектом.
  - `clear(): void` — очищает все данные покупателя, сбрасывая их к начальному состоянию.
  - `validate(): BuyerValidationErrors` — выполняет проверку обязательных полей на непустые значения и возвращает объект ошибок. Тип `BuyerValidationErrors` объявлен в `src/types/index.ts`. Свойство присутствует только в случае ошибки соответствующего поля.
  - `isValid(): boolean` — возвращает `true`, если метод `validate()` не обнаружил ошибок.

## Слой коммуникации

Класс коммуникационного слоя инкапсулирует работу с серверным API и использует композицию с базовым классом `Api`. Он получает объект, реализующий интерфейс `IApi`, и предоставляет методы для получения каталога и отправки заказа.

### Класс ShopApi

- Назначение и зона ответственности: выполнение запросов к серверу «веб-ларёк»: получение списка товаров и отправка заказа.
- Конструктор:
  - `constructor(api: IApi)` — принимает экземпляр клиента API.
- Методы:
  - `getProducts(): Promise<IProduct[]>` — выполняет `GET /product/`, возвращает массив товаров.
  - `postOrder(dto: IOrderRequest): Promise<IOrderResponse>` — выполняет `POST /order/` с данными покупателя и выбранных товаров.

Типы передаваемых данных описаны в `src/types/index.ts`:
- `IProductsResponse` — объект ответа сервера со списком товаров (`total`, `items: IProduct[]`).
- `IOrderRequest` — данные заказа, включающие товары и информацию покупателя.
- `IOrderResponse` — минимальный ответ сервера с идентификатором заказа.

## Слой представления (View)

Слой Представления отвечает за отрисовку интерфейса на основе данных и генерацию событий для Презентера. Каждый класс отвечает за свой участок разметки и использует шаблоны из `src/pages/index.html`.

Общие правила:
- каждый класс View наследуется от базового `Component<T>` и реализует метод `render`;
- разметка модального окна описана отдельным компонентом `Modal` и НЕ является базовым классом для наследования;
- два компонента форм наследуются от общего `FormBase`;
- карточки трёх типов наследуются от общего `CardBase`;
- любое действие пользователя приводит к генерации события через брокер событий.

### Базовые компоненты View

#### Класс Modal
- Назначение: управление контейнером модального окна `#modal-container` — открытие/закрытие, установка контента, блокировка скролла страницы.
- Шаблон: использует существующую разметку модального контейнера (`.modal`, `.modal__content`), внутрь подставляется контент других компонентов.
- Публичный API:
  - `open(content: HTMLElement): void` — открывает модальное окно и монтирует переданный контент.
  - `close(): void` — закрывает модальное окно и очищает содержимое.
  - `setContent(content: HTMLElement): void` — меняет содержимое без закрытия.
- События:
  - `modal:open`
  - `modal:close`

#### Класс PageHeader
- Назначение: шапка сайта (`.header`) с кнопкой корзины и счётчиком товаров.
- Узлы: `.header__basket`, `.header__basket-counter`.
- Публичный API:
  - `setCounter(count: number): void` — обновляет значение счётчика.
- События:
  - `basket:open` — по клику на кнопку корзины.

#### Класс Gallery
- Назначение: корневой контейнер для каталога (`.gallery`). Управляет списком карточек каталога.
- Публичный API:
  - `setItems(items: HTMLElement[]): void` — заменяет список отображаемых карточек.
  - `append(item: HTMLElement): void` — добавляет карточку в конец.

### Карточки товаров

Общий родитель: `CardBase` (наследуется от `Component<IProduct>`)
- Общая логика: установка заголовка, цены, категории, изображения, управление состоянием (доступность/disabled при `price === null`).
- Общие узлы: `.card__title`, `.card__price`, `.card__category`, `.card__image`.
- Общие события:
  - `card:select` — по клику на карточку каталога/превью для показа подробностей.

Дочерние классы используют разные шаблоны из `src/pages/index.html`:

1) `CardCatalog` — шаблон `#card-catalog`
- Узлы: `.gallery__item.card`, общие узлы из `CardBase`.
- События: `card:select` (выбор товара в каталоге).

2) `CardPreview` — шаблон `#card-preview`
- Доп. узлы: `.card__button` (кнопка «В корзину»), `.card__text`.
- События:
  - `card:add` — по клику на кнопку «В корзину».
  - `card:select` — по клику по превью (если требуется показать изображение/детали).

3) `CardBasket` — шаблон `#card-basket`
- Доп. узлы: `.basket__item-delete`, `.basket__item-index`.
- События:
  - `basket:item-remove` — по клику на кнопку удаления в корзине.

### Корзина и оформление

#### Класс BasketView
- Назначение: отображение содержимого корзины внутри модального окна.
- Шаблон: `#basket`.
- Узлы: `.basket__list` (список позиций), `.basket__price` (итог), `.basket__button` (оформить).
- Публичный API:
  - `setItems(items: HTMLElement[]): void` — устанавливает список позиций.
  - `setTotal(total: number): void` — устанавливает сумму заказа.
  - `setDisabled(disabled: boolean): void` — блокирует/разблокирует кнопку «Оформить».
- События:
  - `order:open` — по кнопке «Оформить».
  - `basket:item-remove` — делегируется из элементов списка при клике на удаление.

#### Базовый класс FormBase
- Назначение: общий функционал для форм — управление валидностью и ошибками, блокировка submit, подписка на ввод.
- Общие узлы: `.form`, `.form__errors`, кнопка submit внутри `.modal__actions`.
- Публичный API:
  - `setValid(state: boolean): void` — управляет доступностью кнопки submit.
  - `setErrors(message: string): void` — выводит текст ошибки.
  - `setFieldValue(name: string, value: string): void` — программно устанавливает значение поля.
- События:
  - `form:change` — при изменении любого поля (с данными поля).
  - `form:submit` — при отправке формы (если валидна).

#### Класс OrderForm (наследник FormBase)
- Шаблон: `#order`.
- Поля: выбор оплаты (кнопки `name="card"` и `name="cash"`), `address`.
- Доп. Публичный API:
  - `setPayment(payment: 'online' | 'upon-receipt'): void` — отражает выбор оплаты.
- События:
  - `order:payment` — при выборе способа оплаты.
  - `order:address` — при вводе адреса.
  - `order:next` — успешная отправка формы (кнопка «Далее»).

#### Класс ContactsForm (наследник FormBase)
- Шаблон: `#contacts`.
- Поля: `email`, `phone`.
- События:
  - `contacts:email` — при изменении email.
  - `contacts:phone` — при изменении телефона.
  - `order:submit` — успешная отправка формы (кнопка «Оплатить»).

#### Класс OrderSuccess
- Назначение: вывод итога удачного оформления.
- Шаблон: `#success`.
- Узлы: `.order-success__description` (сумма), `.order-success__close` (кнопка закрытия).
- Публичный API:
  - `setTotal(total: number): void` — устанавливает списанную сумму в текст.
- События:
  - `success:close` — по кнопке «За новыми покупками!».

### Поток событий (пример)
- Пользователь кликает по карточке каталога — `CardCatalog` генерирует `card:select` с `productId`.
- Презентер открывает модалку с `CardPreview` и подписывается на `card:add`.
- Пользователь кликает «В корзину» — `card:add` с `productId` → Презентер обновляет `Cart`, пересчитывает итог, обновляет `PageHeader.setCounter`.
- Пользователь открывает корзину — `basket:open` → Презентер рендерит `BasketView` в `Modal`.
- На «Оформить» — `order:open` → Презентер рендерит `OrderForm`; далее `ContactsForm`; на `order:submit` отправляется заказ.

Таким образом, каждый компонент View отвечает только за свою разметку и взаимодействие пользователя, а вся бизнес-логика и координация находятся в Презентере.

## Слой Презентера (Presenter)

Презентер является центральным звеном приложения, связывающим Модели данных и Представления. Он содержит всю бизнес-логику приложения и отвечает за координацию действий между слоями.

### Подход к реализации

В данном проекте код Презентера реализован непосредственно в файле `src/main.ts`. Такой подход выбран по следующим причинам:

1. **Простота и достаточность**: Приложение состоит из одной страницы, поэтому достаточно одного презентера без дополнительной абстракции.
2. **Читаемость**: Весь код логики приложения находится в одном месте, что упрощает понимание и поддержку.
3. **Соответствие паттерну MVP**: Несмотря на реализацию в основном скрипте, принципы MVP соблюдены — презентер не генерирует события, а только обрабатывает их; представление перерисовывается только при событиях от моделей данных об изменении или при открытии модального окна.

### Принципы работы Презентера

1. **Обработка событий, а не их генерация**: Презентер подписывается на события, генерируемые Моделями данных и Представлениями, и обрабатывает их, вызывая соответствующие методы моделей или представлений.

2. **Разделение ответственности**: 
   - Презентер не знает о деталях DOM-структуры
   - Презентер не хранит данные — это ответственность Моделей
   - Презентер не занимается отрисовкой — это ответственность Представлений

3. **Реактивность через события**: Перерисовка компонентов представления происходит только:
   - При обработке события от модели данных, говорящего об изменении данных (например, `catalog:items`, `cart:changed`)
   - В результате обработки события открытия модального окна (например, `basket:open`, `card:select`)

### Основные обработчики событий

Презентер содержит обработчики для всех событий приложения:

**События моделей данных:**
- `catalog:items` — отображение каталога товаров
- `catalog:selected` — открытие модального окна с превью выбранного товара
- `cart:changed` — обновление счетчика товаров в шапке и содержимого корзины (если она открыта)
- `user:changed` — валидация данных пользователя и обновление состояния форм

**События представлений:**
- `card:select` — выбор товара для просмотра (обновление модели каталога)
- `card:add` — добавление товара в корзину
- `basket:item-remove` — удаление товара из корзины
- `basket:open` — открытие корзины с отображением её содержимого
- `order:open` — открытие формы оформления заказа
- `order:next` — переход ко второй форме оформления (контакты)
- `order:submit` — отправка заказа на сервер
- `order:payment`, `order:address`, `contacts:email`, `contacts:phone` — обновление данных покупателя в модели
- `form:change` — синхронизация данных формы с моделью пользователя
- `form:submit` — маршрутизация отправки формы (переход к следующему шагу или отправка заказа)
- `success:close` — закрытие окна успешного оформления и очистка данных

### Инициализация приложения

При запуске приложения Презентер:
1. Инициализирует брокер событий (`EventEmitter`)
2. Создаёт экземпляры моделей данных (`Catalog`, `Cart`, `User`)
3. Создаёт клиент API и сервис для работы с сервером (`ShopApi`)
4. Инициализирует основные представления (`PageHeader`, `Gallery`, `Modal`)
5. Подписывается на все необходимые события
6. Запрашивает каталог товаров с сервера и сохраняет его в модель `Catalog`

После получения каталога событие `catalog:items` автоматически инициирует отображение товаров на странице.

## События приложения

- Модель каталога:
  - `catalog:items` — список товаров обновлён; данные: `{ items: IProduct[]; total: number }`.
  - `catalog:selected` — выбран товар для просмотра; данные: `{ id: string | null }`.
- Модель корзины:
  - `cart:changed` — содержимое корзины изменилось; данные: `{ items: IProduct[]; count: number; total: number }`.
- Модель пользователя:
  - `user:changed` — изменены данные покупателя; данные: `IBuyer`.
  - `user:payment` — выбран способ оплаты; данные: `{ payment: TPayment }`.
  - `user:address` — обновлён адрес; данные: `{ address: string }`.
  - `user:email` — обновлён email; данные: `{ email: string }`.
  - `user:phone` — обновлён телефон; данные: `{ phone: string }`.
  - `user:cleared` — данные покупателя сброшены.

- `modal:open` — модальное окно открыто.
- `modal:close` — модальное окно закрыто.
- `basket:open` — пользователь открыл корзину (кнопка в шапке).
- `card:select` — выбор товара из каталога/превью; данные: `{ id: string }`.
- `card:add` — добавление товара в корзину из превью; данные: `{ id: string }`.
- `basket:item-remove` — удаление позиции из корзины; данные: `{ id: string }`.
- `order:open` — переход к оформлению заказа из корзины.
- `form:change` — изменение поля любой формы; данные: `{ name: string; value: string }`.
- `form:submit` — отправка формы (базовое событие).
- `order:payment` — выбор способа оплаты; данные: `{ payment: 'online' | 'upon-receipt' }`.
- `order:address` — изменение адреса; данные: `{ address: string }`.
- `order:next` — успешная отправка формы выбора оплаты (используется в презентере по submit `#order`).
- `contacts:email` — изменение email; данные: `{ email: string }`.
- `contacts:phone` — изменение телефона; данные: `{ phone: string }`.
- `order:submit` — финальная отправка заказа (submit формы `#contacts`).
- `success:close` — закрытие окна удачного оформления заказа.